---
title: "MATH1062 Statistics"
subtitle: "Lab Week 3 - Graphical and numerical summaries"
format:
  html:
    embed-resources: true
date: today
author: 'Kierin Chung with scaffold and instructions from Yeeka Yau.'
---

## Welcome to Week 3! ✈️

In this week's lab we will get hands on practice with computing and visualising numerical summaries in R. By the end of this lab, you should be able to make comparative box plots to explore two numerical variables across different factors in a categorical variable and be able to write your own functions in R!

### Learning Outcomes covered in this lab

-   **LO3**. identify appropriate methods to describe, summarise and visualise a given data set
-   **LO5**. apply statistical software such as R to analyse example sets of data

### Specific lab outcomes:

-   Make more new friends and have more fun.
-   Practice statistical thinking with numerical variables, and develop a sense of when different measures of centre and spread are appropriate.
-   Be able to use R to calculate basic numerical summaries and make basic data visualisations, in particular, boxplots.
-   Learn how to write basic functions in R to compute numerical summaries.

## Group Discussion Questions

1.  To quickly review the content from week 2, in your groups, discuss: What’s the difference between **IQR** and **standard deviation**? **Write this on the board**.

IQR is the range between the top and bottom of the middle 50% of the data. It is robust to outliers. 
Standard Deviation is the square root variance between data, ie, how much the data varies from the mean. It is not robust to outliers. 

2.  Also discuss: Why is the z-score *unit-free*? How does this make it useful for comparing variables measured in different units? **Write this on the board**.

z-score is the amount of standard deviations away a certain give value is from the dataset. It is useful for comparing variables in different scenarios as it allows you to see how each value varies from the mean and how much it varies based upon std deviation. 

### Import packages

```{r}
#| message: false
#| warning: false

library(tidyverse)
```

### The data set

This week, we examine a data set of **NYC flight data** from the `nycflights13` package (see <https://github.com/tidyverse/nycflights13>). This data set contains information on all flights that departed from New York City airports (these are abbreviated as EWR, JFK and LGA) to destinations in the United States, Puerto Rico, and the American Virgin Islands) in 2013: 336,776 flights in total. We will just work with a subset of 2000 observations of the data.

```{r}
# Read in the data from the nycflights_sample csv file into the variable flights_sample
flights_sample <- read.csv('nycflights_sample.csv')
```

#### View a "summary" of the data with the `str()` function

```{r}
str(flights_sample)
```

We will use this data set to explore aspects of flight delays.

## Boxplots

3.  Make a **boxplot** of `arr_delay`, using **ggplot** and the `geom_boxplot()` option (try to follow the same code structure as the examples from the previous weeks). In your groups, describe the distribution of delays.

```{r fig.width=6, fig.height=4}
library(ggplot2)

ggplot(data = flights_sample, aes(x = arr_delay)) +
  geom_boxplot() +
  labs(
    title = "Boxplot of Arrival Delays",
    x = "Arrival Delay (minutes)"
  ) +
  theme_minimal() +
  theme(
    axis.text.y = element_blank(),   # Remove x-axis text
    axis.ticks.y = element_blank()   # Remove x-axis ticks
  )

```

**Description of the distribution:**

The distribution is centered around 0 minutes with Q3 at approx less 1 hour. There are lots of outliers, specifically above, with some data being outliers prima facie their delay. 

4.  What would be the most appropriate measure of **centre** and **spread** for the `arr_delay` variable?

Median and IQR. 

5.  The IQR is a little difficult to see from the boxplot. Compute the **IQR** of `arr_delay` then use this to work out the value of the **lower** and **upper thresholds** (LT and QT) of the boxplot. Report the appropriate measure of **centre** and **spread.**\
    *(Hint: Use the IQR rules:* $Q1 - 1.5 \times IQR$ and $Q3 + 1.5 \times IQR$. Q1 and Q3 have been computed for you.)

```{r}
# Q1 and Q3
Q1 <- as.numeric(quantile(flights_sample$arr_delay, probs = 0.25))
Q3 <- as.numeric(quantile(flights_sample$arr_delay, probs = 0.75))

# Your code here to compute the IQR

IQR <- Q3 - Q1

# Compute the upper and lower Thresholds

Upper <- Q3 + 1.5 * IQR 
Lower <- Q1 - 1.5 * IQR

# Compute the median 

Median <- median(flights_sample$arr_delay)

# Print the IQR, LT, UT and median

library(glue)

summary_string <- glue(
  "IQR: {round(IQR, 2)} | ",
  "Lower: {round(Lower, 2)} | ",
  "Upper: {round(Upper, 2)} | ",
  "Median: {round(Median, 2)}"
)

print(summary_string)

```

**Answer**
IQR: 30 | Lower: -62 | Upper: 58 | Median: -5

6.  Create a **comparative** **boxplot** of `arr_delay` by `carrier` (airline) to discuss and answer the following questions in your groups (see the code example from last week's lecture).

```{r}
ggplot(flights_sample, aes(x=arr_delay, y = carrier, fill = carrier)) + 
  geom_boxplot() + 
  labs(title = 'Arrival Delay Boxplot by Carrier', x = 'Arrival Delay', y = 'Carrier') + 
  theme_minimal() + 
  guides(fill = guide_legend(reverse = TRUE))
```

-   **Which airline has the most variation in arrival delays?**

    YV; Mesa Airlines. 

-   **Which airlines have outliers with very large delays?**

    DL; Delta 
    EV; Eva Airways 
    B6; JetBlue Airlines 
    UA; United Airlines 

-   **If you were to choose an airline purely based on reliability of arrival times, which would you choose? Why?**

    AS or HA seem the most reliable. 
    AS; Alaska Airlines
    HA; Hawaian Airlines 
    Perhaps even WN: Southwest Airlines. 

7.  Compute the **sample standard deviation** of `arr_delay` for `flights_sample` using `sd()`.

```{r}
sd(flights_sample$arr_delay)
```

## Introduction to Writing Functions in R

In R, functions are one of the most powerful tools you’ll use.\
You’ve already seen many built-in functions, like `mean()`, `median()`, and `sd()`.

A **function** is simply a way to:

-   **Take some input** (called *parameters,* don't confuse this with population parameters)

-   **Do some work** (run a series of commands)

-   **Return an output**.

### Creating Your Own Functions

We can write our own functions in R using the `function()` keyword.\
**The basic structure is:**

```{r}
# Your code here
function_name <- function(parameter1, parameter2){ 
  # Do something with the parameters 
  c <- parameter1 + parameter2 # example calculation 
  return(c) # send the result back 
  }
```

### The power of R

In R, many operations are *vectorized*. This means that if you perform a calculation on a vector (a list of numbers or a column/variable in your dataset), R automatically applies that calculation to **each element** of the vector. This is one of the reasons R is so concise — you can write one short expression and have it work for an entire dataset.

```{r}
# Example: Adding 5 to each element of a vector
numbers <- c(2, 4, 6, 8)

# Vectorized operation: add 5 to every element
new_numbers <- numbers + 5

# Display the result
new_numbers

```

In this section we will practice writing our own functions! ***Do not worry if you can't get this right away. There are a lot of fiddly things in programming that can only be worked out with experience (some idiosyncrasies you just won't know as a beginner, which can be frustrating). Just try your best and the teaching team will help you if you have questions.***

8.  Write your own function for computing the **population SD**: $\sigma = \sqrt{\frac{1}{N} \sum_{i=1}^N (x_i - \mu)^2}$, do this without using the `sd()` function. Call this function `pop_sd`.

```{r}
pop_sd <- function(x){
  N <- length(x)
  mean <- mean(x)
  val <- 0
  for (i in 1:N) {
    calc_val <- (x[i] - mean)^2
    val <- val + calc_val
  }
  sigma <- ((1/N) * val)^(1/2)
  return(sigma) # Change the 0 in return() to what should be returned from your function
}
```

9.  Use your `pop_sd` function to calculate the population standard deviation of `arr_delay` for `flights_sample` treating these observations as if it was a population.

```{r}
pop_sd(flights_sample$arr_delay)
```

10. Recall that "standard units" allow us to compare a numerical variable for different groups in terms of standard deviations. Write your own function `z_score()` that takes a vector `x` and returns a vector of z-scores.\
    (*Hint:* Use `mean()` and `sd()` inside your function.)

```{r}
# Your code here
z_score <- function(x){
  mean <- mean(x)
  sd <- sd(x)
  z <- ((x-mean)/sd)
  
  return(z)
}

```

Here we create a new column in `flights_sample` called `arr_delay_z_score` by applying your `z_score` function to the `arr_delay` variable. Just read the code and run it. You'll need to scroll to the right of the table to see the `arr_delay_z_score` column.

```{r}
#  Create a new column called arr_delay_z_score with the mutate() function 
flights_sample %>%
  mutate(arr_delay_z_score = z_score(arr_delay)) ->
  flights_sample #save it back into the flights_sample variable

print(head(flights_sample))
```

Which flight (in `flights_sample`) has the **highest z-score** for `arr_delay`? Here we use the `sort_by()` function. You'll need to scroll to the right of the table to see the `arr_delay_z_score` column.

```{r}
# Run this code
sort_by(flights_sample, flights_sample$arr_delay_z_score, decreasing = TRUE)
```

In this example, flight DL2047 had the highest z-score. It was over 18 standard deviations above the average in lateness.
